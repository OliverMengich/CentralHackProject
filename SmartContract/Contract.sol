
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity > 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract Contract {
    
    modifier acceptMessage(){
        require(msg.pubkey() == tvm.pubkey(), 102);
        tvm.accept();
        _;
    }
    constructor() public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();
    }
    struct Member{
        uint index;
        string fullname;
        string gender;
        uint age;
        uint idnumber;
        string phonenumber;
        string password;
        string occupation;
    }
    Member[] members;
    function addMembers(uint index,string fullName, string gender, uint age, uint idnumber,string phonenumber, string password, string occupation) public acceptMessage {
        Member newMember = Member({
            index: index,
            fullName:fullName,
            gender: gender,
            age: age,
            phonenumber: phonenumber,
            password: password,
            occupation: occupation
        });
        members.push(newMember);
    }
    struct MoneySent{
        string fullName;
        uint amount;
        string timestamp;
    }
    function removeMembers(uint index) external acceptMessage{
        delete members[index];
    }
    // contains details of who sent the money, amount and what time
    MoneySent[] moneysent; 
    function sendCash(string fullName, uint128 amount,string timestamp) external acceptMessage{
        MoneySent m = MoneySent({
            fullName: fullName,
            amount: amount,
            timestamp: timestamp
        });
        moneysent.push(m);
    }
    enum ProjectState {PENDING,ACTIVE,COMPLETE, CANCELLED}
    struct Project{
        string projectname;
        string description;
        uint128 amount;
        ProjectState condition;
        uint votes;
        mapping(string =>bool) approvals;
    }
    Project[] projects;
    event ProjectPassed(string text,uint128 amount, uint32 timestamp);
    function initiateProject(string description, string projectname,uint amount) external acceptMessage {
        Project newproject = Project({
            projectname:projectname,
            description: description,
            amount: amount,
            condition: ProjectState.PENDING,
            votes:0
        });
    }
    function approveProject(string username, uint index) public view acceptMessage returns(Project){
        Project proj = projects[index];
        require(proj.approvals[username] == false);
        proj.votes++;
        return proj;
    }
    function activateproject(uint index) public view acceptMessage returns(Project){
        Project proj = projects[index];
        require(proj.votes > (members.length)/2);
        require(proj.condition ==ProjectState.PENDING);
        proj.condition = ProjectState.ACTIVE;
        emit ProjectPassed('Project Passed CONTINUE TO PRODUCTION',amount, now);
        return proj;
    }
    function completeproject(uint index) public view returns(Project){
        Project p = projects[index];
        p.condition = ProjectState.COMPLETE;
        return p;
    }
    struct Finance{
        string name;
        uint amount;
        string timestamp;
    }
    Finance[] finances;
    function microFinancing(string name, uint amount, string timestamp) public view acceptMessage{
        Finance f = Finance({
            name:name,
            amount: amount,
            timestamp:timestamp
        });
        finances.push(f);
    }
}
